{"/home/travis/build/npmtest/node-npmtest-db-migrate/test.js":"/* istanbul instrument in package npmtest_db_migrate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-db-migrate/lib.npmtest_db_migrate.js":"/* istanbul instrument in package npmtest_db_migrate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_db_migrate = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_db_migrate = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-db-migrate/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-db-migrate && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_db_migrate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_db_migrate\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_db_migrate.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_db_migrate.rollup.js'] =\n            local.assetsDict['/assets.npmtest_db_migrate.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_db_migrate.__dirname + '/lib.npmtest_db_migrate.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/index.js":"var recursive = require('final-fs').readdirRecursive;\nvar fs = require('fs');\nvar driver = require('./lib/driver');\nvar path = require('path');\nvar log = require('./lib/log');\nvar Migrator = require('./lib/migrator');\n\nexports.dataType = require('./lib/data_type');\nexports.config = require('./lib/config');\n\nexports.connect = function(config, callback) {\n  driver.connect(config, function(err, db) {\n    if (err) { callback(err); return; }\n\n    if(global.migrationMode)\n    {\n      var dirPath = path.resolve(config['migrations-dir'] || 'migrations');\n\n      if(global.migrationMode !== 'all')\n      {\n        var switched = false,\n            newConf;\n\n        try {\n          newConf = require(path.resolve(config['migrations-dir'] || 'migrations', global.migrationMode) + '/config.json');\n          log.info('loaded extra config for migration subfolder: \"' + global.migrationMode + '/config.json\"');\n          switched = true;\n        } catch(e) {}\n\n        if(switched) {\n\n          db.switchDatabase(newConf, function()\n          {\n            global.locTitle = global.migrationMode;\n            callback(null, new Migrator(db, config['migrations-dir']));\n          });\n        }\n        else\n        {\n          global.locTitle = global.migrationMode;\n          callback(null, new Migrator(db, config['migrations-dir']));\n        }\n      }\n      else\n      {\n      recursive(dirPath, false, config['migrations-dir'] || 'migrations')\n      .then(function(files) {\n          var oldClose = db.close;\n\n          files = files.filter(function (file) {\n            return file !== 'migrations' && fs.statSync(file).isDirectory();\n          });\n\n          files.push('');\n\n          db.close = function(cb) { migrationFiles(files, callback, config, db, oldClose, cb); };\n\n          db.close();\n        });\n      }\n    }\n    else\n      callback(null, new Migrator(db, config['migrations-dir']));\n\n  });\n};\n\nexports.driver = function(config, callback) {\n\n  driver.connect(config, callback);\n};\n\nfunction migrationFiles(files, callback, config, db, close, cb) {\n  var file,\n      switched = false,\n      newConf;\n\n  if(files.length === 1)\n  {\n    db.close = close;\n  }\n\n  file = files.pop();\n\n  if(file !== '')\n  {\n\n    try {\n      newConf = require(path.resolve(file + '/config.json'));\n      log.info('loaded extra config for migration subfolder: \"' + file + '/config.json\"');\n      switched = true;\n    } catch(e) {}\n  }\n\n  db.switchDatabase((switched) ? newConf : config.database, function()\n  {\n    global.matching = file.substr(file.indexOf(config['migrations-dir'] || 'migrations') +\n        (config['migrations-dir'] || 'migrations').length + 1);\n\n    if(global.matching.length === 0)\n      global.matching = '';\n\n\n    global.locTitle = global.matching;\n    callback(null, new Migrator(db, config['migrations-dir']));\n\n    if(typeof(cb) === 'function')\n      cb();\n\n  });\n}\n\nexports.createMigration = function(migration, callback) {\n  migration.write(function(err) {\n  if (err) { callback(err); return; }\n  callback(null, migration);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/driver/index.js":"var log = require('../log');\n\nexports.connect = function(config, callback) {\n  if (config.driver === undefined) {\n    throw new Error('config must include a driver key specifying which driver to use');\n  }\n\n  var req = './' + config.driver;\n  log.verbose('require:', req);\n  var driver = require(req);\n  log.verbose('connecting');\n  driver.connect(config, function(err, db) {\n    if (err) { callback(err); return; }\n    log.verbose('connected');\n    callback(null, db);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/log.js":"this.isSilent = false\n\nexports.silence = function (isSilent) {\n  return this.isSilent = isSilent;\n};\nexports.info = function () {\n  if (!this.isSilent || global.verbose) {\n    Array.prototype.unshift.call(arguments, '[INFO]');\n    console.info.apply(console, arguments);\n  }\n};\nexports.warn = function () {\n  if (!this.isSilent || global.verbose) {\n    var args = Array.prototype.unshift.call(arguments, '[WARN]');\n    console.warn.apply(console, arguments);\n  }\n};\nexports.error = function () {\n  if (!this.isSilent || global.verbose) {\n    var args = Array.prototype.unshift.call(arguments, '[ERROR]');\n    console.error.apply(console, arguments);\n  }\n};\nexports.sql = function(sql) {\n  if (!this.isSilent && (global.dryRun || global.verbose)) {\n    var args = Array.prototype.slice.call(arguments).slice(1);\n    args = args.slice(0, args.length - 1);\n    if(global.verbose) {\n      if(args.length > 0) {\n        console.log('[SQL]', sql, args);\n      } else {\n        console.log('[SQL]', sql);\n      }\n    }\n    if (global.dryRun) {\n      if(args.length > 0) {\n        console.log(sql, args);\n      } else {\n        console.log(sql);\n      }\n    }\n  }\n};\nexports.verbose = function() {\n  if (global.verbose) {\n    Array.prototype.unshift.call(arguments, '[INFO]');\n    console.log.apply(console, arguments);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/migrator.js":"var async = require('async');\nvar dbmUtil = require('./util');\nvar Migration = require('./migration');\nvar log = require('./log');\n\nfunction isIncludedInUp(migration, destination) {\n  if(!destination) {\n    return true;\n  }\n  var migrationTest = migration.name.substring(0, Math.min(migration.name.length, destination.length));\n  var destinationTest = destination.substring(0, Math.min(migration.name.length, destination.length));\n  return migrationTest <= destinationTest;\n}\n\nfunction filterUp(allMigrations, completedMigrations, destination, count) {\n  var sortFn = function(a, b) {\n    return a.name.slice(0, a.name.indexOf('-')) - b.name.slice(0, b.name.indexOf('-'));\n  };\n\n  return allMigrations.sort(sortFn)\n  .filter(function(migration) {\n    var hasRun = completedMigrations.some(function(completedMigration) {\n      return completedMigration.name === migration.name;\n    });\n    return !hasRun;\n  })\n  .filter(function(migration) {\n    return isIncludedInUp(migration, destination);\n  })\n  .slice(0, count);\n}\n\nfunction filterDown(completedMigrations, count) {\n  return completedMigrations.slice(0, count);\n}\n\n\nMigrator = function(driver, migrationsDir) {\n  this.driver = driver;\n  this.migrationsDir = migrationsDir;\n};\n\nMigrator.prototype = {\n  createMigrationTable: function(callback) {\n    this.driver.createMigrationTable(callback);\n  },\n\n  writeMigrationRecord: function(migration, callback) {\n    function onComplete(err) {\n      if (err) {\n        log.error(migration.name, err);\n      } else {\n        log.info('Processed migration', migration.name);\n      }\n      callback(err);\n    }\n    this.driver.addMigrationRecord(global.matching + '/' + migration.name, onComplete);\n  },\n\n  deleteMigrationRecord: function(migration, callback) {\n    function onComplete(err) {\n      if (err) {\n        log.error(migration.name, err);\n      } else {\n        log.info('Processed migration', migration.name);\n      }\n      callback(err);\n    }\n    this.driver.deleteMigration(global.matching + '/' + migration.name, function(err) {\n\n      if(!global.matching) {\n\n        this.driver.deleteMigration(migration.name, onComplete);\n      }\n      else {\n\n        onComplete.apply(err);\n      }\n    }.bind(this));\n  },\n\n  up: function(funcOrOpts, callback) {\n    if (dbmUtil.isFunction(funcOrOpts)) {\n      funcOrOpts(this.driver, callback);\n    } else {\n      this.upToBy(funcOrOpts.destination, funcOrOpts.count, callback);\n    }\n  },\n\n  down: function(funcOrOpts, callback) {\n    if (dbmUtil.isFunction(funcOrOpts)) {\n      funcOrOpts(this.driver, callback);\n    } else {\n      this.downToBy(funcOrOpts.count, callback);\n    }\n  },\n\n  upToBy: function(partialName, count, callback) {\n    var self = this;\n    Migration.loadFromFilesystem(self.migrationsDir, function(err, allMigrations) {\n      if (err) { callback(err); return; }\n\n      Migration.loadFromDatabase(self.migrationsDir, self.driver, function(err, completedMigrations) {\n        if (err) { callback(err); return; }\n        var toRun = filterUp(allMigrations, completedMigrations, partialName, count);\n\n        if (toRun.length === 0) {\n          log.info('No migrations to run');\n          callback(null);\n          return;\n        }\n\n        async.forEachSeries(toRun, function(migration, next) {\n          log.verbose('preparing to run up migration:', migration.name);\n          self.driver.startMigration(function() {\n            self.up(migration.up.bind(migration), function(err) {\n              if (err) { callback(err); return; }\n              self.writeMigrationRecord(migration, function() { self.driver.endMigration(next); });\n            });\n          });\n        }, callback);\n      });\n    });\n  },\n\n  downToBy: function(count, callback) {\n    var self = this;\n    Migration.loadFromDatabase(self.migrationsDir, self.driver, function(err, completedMigrations) {\n      if (err) { return callback(err); }\n\n      var toRun = filterDown(completedMigrations, count);\n\n      if (toRun.length === 0) {\n        log.info('No migrations to run');\n        callback(null);\n        return;\n      }\n\n      async.forEachSeries(toRun, function(migration, next) {\n        log.verbose('preparing to run down migration:', migration.name);\n        self.down(migration.down.bind(migration), function(err) {\n          if (err) { callback(err); return; }\n          self.deleteMigrationRecord(migration, next);\n        });\n      }, callback);\n    });\n  }\n};\n\nmodule.exports = Migrator;\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/util.js":"exports.lpad = function(str, padChar, totalLength) {\n  str = str.toString();\n  var neededPadding = totalLength - str.length;\n  for (var i = 0; i < neededPadding; i++) {\n    str = padChar + str;\n  }\n  return str;\n};\n\nexports.shallowCopy = function(obj) {\n  var newObj = {};\n  for (var prop in obj) {\n    newObj[prop] = obj[prop];\n  }\n  return newObj;\n};\n\nexports.toArray = function(obj) {\n  var arr = [];\n  for (var prop in obj) {\n    arr[prop] = obj[prop];\n  }\n  return arr;\n};\n\nexports.isArray = function(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\nexports.isFunction = function(obj) {\n  return typeof(obj) == 'function';\n};\n\nexports.isString = function(obj) {\n  return typeof(obj) == 'string';\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/migration.js":"var fs = require('fs');\nvar path = require('path');\nvar inflection = require('./inflection');\nvar lpad = require('./util').lpad;\nvar config = require('./config');\nvar log = require('./log');\n\nvar filesRegEx = /\\.js$/;\nvar coffeeSupported = false;\nvar coffeeModule = null;\ntry {\n  coffeeModule = require('coffee-script');\n  if (coffeeModule && coffeeModule.register) coffeeModule.register();\n  coffeeSupported = true;\n  filesRegEx = /\\.(js|coffee)$/;\n} catch (e) {}\n\nfunction formatPath(dir, name) {\n  return path.join(dir, name);\n}\n\nfunction formatName(title, date) {\n  return formatDate(date) + '-' + formatTitle(title);\n}\n\nfunction formatDate(date) {\n  return [\n    date.getUTCFullYear(),\n    lpad(date.getUTCMonth() + 1, '0', 2),\n    lpad(date.getUTCDate(), '0', 2),\n    lpad(date.getUTCHours(), '0', 2),\n    lpad(date.getUTCMinutes(), '0', 2),\n    lpad(date.getUTCSeconds(), '0', 2)\n  ].join('');\n}\n\nfunction formatTitle(title) {\n  return inflection.dasherize(title);\n}\n\nfunction parseDate(name) {\n  var date = new Date();\n  var match = name.match(/(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})-[^\\.]+/);\n  date.setUTCFullYear(match[1]);\n  date.setUTCDate(match[3]);\n  date.setUTCMonth(match[2] - 1);\n  date.setUTCHours(match[4]);\n  date.setUTCMinutes(match[5]);\n  date.setUTCSeconds(match[6]);\n  return date;\n}\n\nfunction parseTitle(name) {\n  var match = name.match(/\\d{14}-([^\\.]+)/);\n  var dashed = match[1];\n  return inflection.humanize(dashed, true);\n}\n\nfunction writeMigrationRecord(db, migration, callback) {\n  db._runSql('INSERT INTO ' + global.migrationTable + ' (name, run_on) VALUES (?, ?)', [migration.name, new Date()], callback);\n}\n\nMigration = function() {\n  if (arguments.length >= 3) {\n    this.title = arguments[0];\n    this.date = arguments[2];\n    this.name = formatName(this.title, this.date);\n    this.path = formatPath(arguments[1], this.name);\n    this.templateType = arguments[3];\n  } else if (arguments.length == 1) {\n    this.path = arguments[0];\n    this.name = Migration.parseName(this.path);\n    this.date = parseDate(this.name);\n    this.title = parseTitle(this.name);\n  }\n};\n\nMigration.prototype.defaultCoffeeTemplate = function() {\n  return [\n    \"var dbm = -> global.dbm or require 'db-migrate'\",\n    \"type   = dbm.dataType\",\n    \"\",\n    \"exports.up = (db, callback) ->\",\n    \"\",\n    \"\",\n    \"exports.down = (db, callback) ->\",\n    \"\",\n    \"\",\n    \"\"\n  ].join(\"\\n\");\n};\n\nMigration.prototype.defaultJsTemplate = function() {\n  return [\n    \"var dbm = global.dbm || require('db-migrate');\",\n    \"var type = dbm.dataType;\",\n    \"\",\n    \"exports.up = function(db, callback) {\",\n    \"  callback();\",\n    \"};\",\n    \"\",\n    \"exports.down = function(db, callback) {\",\n    \"  callback();\",\n    \"};\",\n    \"\"\n  ].join(\"\\n\");\n};\n\nMigration.prototype.defaultSqlTemplate = function() {\n  return \"/* Replace with your SQL commands */\";\n};\n\n\nMigration.prototype.sqlFileLoaderTemplate = function() {\n  return [\n    \"var dbm = global.dbm || require('db-migrate');\",\n    \"var type = dbm.dataType;\",\n    \"var fs = require('fs');\",\n    \"var path = require('path');\",\n    \"\",\n    \"exports.up = function(db, callback) {\",\n    \"  var filePath = path.join(__dirname + '/sqls/\"+this.name.replace('.js', '')+\"-up.sql');\",\n    \"  fs.readFile(filePath, {encoding: 'utf-8'}, function(err,data){\",\n    \"    if (err) return callback(err);\",\n    \"      console.log('received data: ' + data);\",\n    \"\",\n    \"    db.runSql(data, function(err) {\",\n    \"      if (err) return callback(err);\",\n    \"      callback();\",\n    \"    });\",\n    \"  });\",\n    \"};\",\n    \"\",\n    \"exports.down = function(db, callback) {\",\n    \"  var filePath = path.join(__dirname + '/sqls/\"+this.name.replace('.js', '')+\"-down.sql');\",\n    \"  fs.readFile(filePath, {encoding: 'utf-8'}, function(err,data){\",\n    \"    if (err) return callback(err);\",\n    \"      console.log('received data: ' + data);\",\n    \"\",\n    \"    db.runSql(data, function(err) {\",\n    \"      if (err) return callback(err);\",\n    \"      callback();\",\n    \"    });\",\n    \"  });\",\n    \"};\",\n    \"\"\n  ].join(\"\\n\");\n};\n\nMigration.TemplateType = {\n  DEFAULT_JS: 0,\n  DEFAULT_SQL: 1,\n  SQL_FILE_LOADER: 2,\n  DEFAULT_COFFEE: 3\n};\n\nMigration.prototype.getTemplate = function() {\n  switch (this.templateType) {\n    case Migration.TemplateType.DEFAULT_SQL:\n      return this.defaultSqlTemplate();\n    case Migration.TemplateType.SQL_FILE_LOADER:\n      return this.sqlFileLoaderTemplate();\n    case Migration.TemplateType.DEFAULT_COFFEE:\n      return this.defaultCoffeeTemplate();\n    case Migration.TemplateType.DEFAULT_JS:\n    default:\n      return this.defaultJsTemplate();\n  }\n};\n\nMigration.prototype._up = function() {\n  return require(this.path).up.apply(this, arguments);\n};\n\nMigration.prototype._down = function() {\n  return require(this.path).down.apply(this, arguments);\n};\n\nMigration.prototype.write = function(callback) {\n  fs.writeFile(this.path, this.getTemplate(), callback);\n};\n\nMigration.prototype.up = function(db, callback) {\n  this._up(db, callback);\n};\n\nMigration.prototype.down = function(db, callback) {\n  this._down(db, callback);\n};\n\nMigration.parseName = function(path) {\n  var match = path.match(/(\\d{14}-[^.]+)(?:\\.*?)?/);\n  return match[1];\n};\n\nMigration.loadFromFilesystem = function(dir, callback) {\n  log.verbose('loading migrations from dir', dir);\n  fs.readdir(dir, function(err, files) {\n    if (err) { callback(err); return; }\n    var coffeeWarn = true;\n    files = files.filter(function(file) {\n      if (coffeeWarn && !coffeeSupported && /\\.coffee$/.test(file)) {\n        log.warn('CoffeeScript not installed');\n        coffeeWarn = false;\n      }\n      return filesRegEx.test(file);\n    });\n    var migrations = files.sort().map(function(file) {\n      return new Migration(path.join(dir, file));\n    });\n    callback(null, migrations);\n  });\n};\n\nMigration.loadFromDatabase = function(dir, driver, callback) {\n  log.verbose('loading migrations from database');\n  driver.allLoadedMigrations(function(err, dbResults) {\n    if (err && !global.dryRun) { callback(err); return; }\n    else if (err && global.dryRun) {\n      dbResults = []\n    }\n    var migrations = dbResults.filter(function(result) {\n      return result.name.substr(0,result.name.lastIndexOf('/')) === global.matching;\n    }).map(function(result) {\n      return new Migration(path.join(dir, result.name));\n    });\n\n    callback(null, migrations);\n  });\n};\n\nmodule.exports = Migration;\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/inflection.js":"/*\nCopyright (c) 2010 Ryan Schuft (ryan.schuft@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/*\n  This code is based in part on the work done in Ruby to support\n  infection as part of Ruby on Rails in the ActiveSupport's Inflector\n  and Inflections classes.  It was initally ported to Javascript by\n  Ryan Schuft (ryan.schuft@gmail.com) in 2007. It has since been modified\n  to not alter the String prototype.\n\n  Currently implemented functions:\n\n    pluralize(str, plural) == String\n      renders a singular English language noun into its plural form\n      normal results can be overridden by passing in an alternative\n\n    singularize(str, singular) == String\n      renders a plural English language noun into its singular form\n      normal results can be overridden by passing in an alterative\n\n    camelize(str, lowFirstLetter) == String\n      renders a lower case underscored word into camel case\n      the first letter of the result will be upper case unless you pass true\n      also translates \"/\" into \"::\" (underscore does the opposite)\n\n    underscore(str) == String\n      renders a camel cased word into words seperated by underscores\n      also translates \"::\" back into \"/\" (camelize does the opposite)\n\n    humanize(str, lowFirstLetter) == String\n      renders a lower case and underscored word into human readable form\n      defaults to making the first letter capitalized unless you pass true\n\n    capitalize(str) == String\n      renders all characters to lower case and then makes the first upper\n\n    dasherize(str) == String\n      renders all underbars and spaces as dashes\n\n    titleize(str) == String\n      renders words into title casing (as for book titles)\n\n    demodulize(str) == String\n      renders class names that are prepended by modules into just the class\n\n    tableize(str) == String\n      renders camel cased singular words into their underscored plural form\n\n    classify(str) == String\n      renders an underscored plural word into its camel cased singular form\n\n    foreignKey(str, dropIdUbar) == String\n      renders a class name (camel cased singular noun) into a foreign key\n      defaults to seperating the class from the id with an underbar unless\n      you pass true\n\n    ordinalize(str) == String\n      renders all numbers found in the string into their sequence like \"22nd\"\n*/\n\n/*\n  This is a list of nouns that use the same form for both singular and plural.\n  This list should remain entirely in lower case to correctly match Strings.\n*/\nvar uncountableWords = [\n  'equipment', 'information', 'rice', 'money', 'species', 'series',\n  'fish', 'sheep', 'moose', 'deer', 'news'\n];\n\n/*\n  These rules translate from the singular form of a noun to its plural form.\n*/\nvar pluralRules = [\n  [new RegExp('(m)an$', 'gi'),                 '$1en'],\n  [new RegExp('(pe)rson$', 'gi'),              '$1ople'],\n  [new RegExp('(child)$', 'gi'),               '$1ren'],\n  [new RegExp('^(ox)$', 'gi'),                 '$1en'],\n  [new RegExp('(ax|test)is$', 'gi'),           '$1es'],\n  [new RegExp('(octop|vir)us$', 'gi'),         '$1i'],\n  [new RegExp('(alias|status)$', 'gi'),        '$1es'],\n  [new RegExp('(bu)s$', 'gi'),                 '$1ses'],\n  [new RegExp('(buffal|tomat|potat)o$', 'gi'), '$1oes'],\n  [new RegExp('([ti])um$', 'gi'),              '$1a'],\n  [new RegExp('sis$', 'gi'),                   'ses'],\n  [new RegExp('(?:([^f])fe|([lr])f)$', 'gi'),  '$1$2ves'],\n  [new RegExp('(hive)$', 'gi'),                '$1s'],\n  [new RegExp('([^aeiouy]|qu)y$', 'gi'),       '$1ies'],\n  [new RegExp('(x|ch|ss|sh)$', 'gi'),          '$1es'],\n  [new RegExp('(matr|vert|ind)ix|ex$', 'gi'),  '$1ices'],\n  [new RegExp('([m|l])ouse$', 'gi'),           '$1ice'],\n  [new RegExp('(quiz)$', 'gi'),                '$1zes'],\n  [new RegExp('s$', 'gi'),                     's'],\n  [new RegExp('$', 'gi'),                      's']\n];\n\n/*\n  These rules translate from the plural form of a noun to its singular form.\n*/\nvar singularRules = [\n  [new RegExp('(m)en$', 'gi'),                                                       '$1an'],\n  [new RegExp('(pe)ople$', 'gi'),                                                    '$1rson'],\n  [new RegExp('(child)ren$', 'gi'),                                                  '$1'],\n  [new RegExp('([ti])a$', 'gi'),                                                     '$1um'],\n  [new RegExp('((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi'), '$1$2sis'],\n  [new RegExp('(hive)s$', 'gi'),                                                     '$1'],\n  [new RegExp('(tive)s$', 'gi'),                                                     '$1'],\n  [new RegExp('(curve)s$', 'gi'),                                                    '$1'],\n  [new RegExp('([lr])ves$', 'gi'),                                                   '$1f'],\n  [new RegExp('([^fo])ves$', 'gi'),                                                  '$1fe'],\n  [new RegExp('([^aeiouy]|qu)ies$', 'gi'),                                           '$1y'],\n  [new RegExp('(s)eries$', 'gi'),                                                    '$1eries'],\n  [new RegExp('(m)ovies$', 'gi'),                                                    '$1ovie'],\n  [new RegExp('(x|ch|ss|sh)es$', 'gi'),                                              '$1'],\n  [new RegExp('([m|l])ice$', 'gi'),                                                  '$1ouse'],\n  [new RegExp('(bus)es$', 'gi'),                                                     '$1'],\n  [new RegExp('(o)es$', 'gi'),                                                       '$1'],\n  [new RegExp('(shoe)s$', 'gi'),                                                     '$1'],\n  [new RegExp('(cris|ax|test)es$', 'gi'),                                            '$1is'],\n  [new RegExp('(octop|vir)i$', 'gi'),                                                '$1us'],\n  [new RegExp('(alias|status)es$', 'gi'),                                            '$1'],\n  [new RegExp('^(ox)en', 'gi'),                                                      '$1'],\n  [new RegExp('(vert|ind)ices$', 'gi'),                                              '$1ex'],\n  [new RegExp('(matr)ices$', 'gi'),                                                  '$1ix'],\n  [new RegExp('(quiz)zes$', 'gi'),                                                   '$1'],\n  [new RegExp('s$', 'gi'),                                                           '']\n];\n\n/*\n  This is a list of words that should not be capitalized for title case\n*/\nvar nonTitlecasedWords = [\n  'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at',\n  'by', 'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over',\n  'with', 'for'\n];\n\n/*\n  These are regular expressions used for converting between String formats\n*/\nvar idSuffix = new RegExp('(_ids|_id)$', 'g');\nvar underbar = new RegExp('_', 'g');\nvar spaceOrUnderbar = new RegExp('[ _]', 'g');\nvar dashOrUnderbar = new RegExp('[-_]', 'g');\nvar uppercase = new RegExp('([A-Z])', 'g');\nvar underbarPrefix = new RegExp('^_');\n\n/*\n  This is a helper method that applies rules based replacement to a String\n  Signature:\n    applyRules(str, rules, skip, override) == String\n  Arguments:\n    str - String - String to modify and return based on the passed rules\n    rules - Array: [RegExp, String] - Regexp to match paired with String to use for replacement\n    skip - Array: [String] - Strings to skip if they match\n    override - String (optional) - String to return as though this method succeeded (used to conform to APIs)\n  Returns:\n    String - passed String modified by passed rules\n  Examples:\n    applyRules(\"cows\", InflectionJs.singularRules) === 'cow'\n*/\nvar applyRules = function(str, rules, skip, override) {\n  if (override) {\n    str = override;\n  } else {\n    var ignore = (skip.indexOf(str.toLowerCase()) > -1);\n    if (!ignore) {\n      for (var x = 0; x < rules.length; x++) {\n        if (str.match(rules[x][0])) {\n          str = str.replace(rules[x][0], rules[x][1]);\n          break;\n        }\n      }\n    }\n  }\n  return str;\n};\n\n/*\n  This lets us detect if an Array contains a given element\n  Signature:\n    indexOf(array, item, fromIndex, compareFunc) == Integer\n  Arguments:\n    array - Array - array to find object in\n    item - Object - object to locate in the Array\n    fromIndex - Integer (optional) - starts checking from this position in the Array\n    compareFunc - Function (optional) - function used to compare Array item vs passed item\n  Returns:\n    Integer - index position in the Array of the passed item\n  Examples:\n    ['hi','there'].indexOf(\"guys\") === -1\n    ['hi','there'].indexOf(\"hi\") === 0\n*/\nexports.indexOf = function(array, item, fromIndex, compareFunc) {\n  if (!fromIndex) {\n    fromIndex = -1;\n  }\n  var index = -1;\n  for (var i = fromIndex; i < array.length; i++) {\n    if (array[i] === item || compareFunc && compareFunc(array[i], item)) {\n      index = i;\n      break;\n    }\n  }\n  return index;\n};\n\n/*\n  This function adds plurilization support to every String object\n    Signature:\n      pluralize(str, plural) == String\n    Arguments:\n      str - String - string to apply inflection on\n      plural - String (optional) - overrides normal output with said String\n    Returns:\n      String - singular English language nouns are returned in plural form\n    Examples:\n      \"person\".pluralize() == \"people\"\n      \"octopus\".pluralize() == \"octopi\"\n      \"Hat\".pluralize() == \"Hats\"\n      \"person\".pluralize(\"guys\") == \"guys\"\n*/\nexports.pluralize = function(str, plural) {\n  return applyRules(str, pluralRules, uncountableWords, plural);\n};\n\n/*\n  This function adds singularization support to every String object\n    Signature:\n      singularize(str, singular) == String\n    Arguments:\n      str - String - string to apply inflection on\n      singular - String (optional) - overrides normal output with said String\n    Returns:\n      String - plural English language nouns are returned in singular form\n    Examples:\n      \"people\".singularize() == \"person\"\n      \"octopi\".singularize() == \"octopus\"\n      \"Hats\".singularize() == \"Hat\"\n      \"guys\".singularize(\"person\") == \"person\"\n*/\nexports.singularize = function(str, singular) {\n  return applyRules(str, singularRules, uncountableWords, singular);\n};\n\n/*\n  This function adds camelization support to every String object\n    Signature:\n      camelize(str, lowFirstLetter) == String\n    Arguments:\n      str - String - string to apply inflection on\n      lowFirstLetter - boolean (optional) - default is to capitalize the first\n        letter of the results... passing true will lowercase it\n    Returns:\n      String - lower case underscored words will be returned in camel case\n        additionally '/' is translated to '::'\n    Examples:\n      \"message_properties\".camelize() == \"MessageProperties\"\n      \"message_properties\".camelize(true) == \"messageProperties\"\n*/\nexports.camelize = function(str, lowFirstLetter) {\n  str = str.toLowerCase();\n  var str_path = str.split('/');\n  for (var i = 0; i < str_path.length; i++) {\n    var str_arr = str_path[i].split('_');\n    var initX = ((lowFirstLetter && i + 1 === str_path.length) ? (1) : (0));\n    for (var x = initX; x < str_arr.length; x++) {\n      str_arr[x] = str_arr[x].charAt(0).toUpperCase() + str_arr[x].substring(1);\n    }\n    str_path[i] = str_arr.join('');\n  }\n  str = str_path.join('::');\n  return str;\n};\n\n/*\n  This function adds underscore support to every String object\n    Signature:\n      underscore(str) == String\n    Arguments:\n      str - String - string to apply inflection on\n    Returns:\n      String - camel cased words are returned as lower cased and underscored\n        additionally '::' is translated to '/'\n    Examples:\n      \"MessageProperties\".camelize() == \"message_properties\"\n      \"messageProperties\".underscore() == \"message_properties\"\n*/\nexports.underscore = function(str) {\n  var str_path = str.split('::');\n  for (var i = 0; i < str_path.length; i++) {\n    str_path[i] = str_path[i].replace(uppercase, '_$1');\n    str_path[i] = str_path[i].replace(underbarPrefix, '');\n  }\n  str = str_path.join('/').toLowerCase();\n  return str;\n};\n\n/*\n  This function adds humanize support to every String object\n    Signature:\n      humanize(str, lowFirstLetter) == String\n    Arguments:\n      str - String - string to apply inflection on\n      lowFirstLetter - boolean (optional) - default is to capitalize the first\n        letter of the results... passing true will lowercase it\n    Returns:\n      String - lower case underscored words will be returned in humanized form\n    Examples:\n      \"message_properties\".humanize() == \"Message properties\"\n      \"message_properties\".humanize(true) == \"message properties\"\n*/\nexports.humanize = function(str, lowFirstLetter) {\n  str = str.toLowerCase();\n  str = str.replace(idSuffix, '');\n  str = str.replace(dashOrUnderbar, ' ');\n  if (!lowFirstLetter) {\n    str = exports.capitalize(str);\n  }\n  return str;\n};\n\n/*\n  This function adds capitalization support to every String object\n    Signature:\n      capitalize(str) == String\n    Arguments:\n      str - String - string to apply inflection on\n    Returns:\n      String - all characters will be lower case and the first will be upper\n    Examples:\n      \"message_properties\".capitalize() == \"Message_properties\"\n      \"message properties\".capitalize() == \"Message properties\"\n*/\nexports.capitalize = function(str) {\n  str = str.toLowerCase();\n  str = str.substring(0, 1).toUpperCase() + str.substring(1);\n  return str;\n};\n\n/*\n  This function adds dasherization support to every String object\n    Signature:\n      dasherize(str) == String\n    Arguments:\n      str - String - string to apply inflection on\n    Returns:\n      String - replaces all spaces or underbars with dashes\n    Examples:\n      \"message_properties\".capitalize() == \"message-properties\"\n      \"Message Properties\".capitalize() == \"Message-Properties\"\n*/\nexports.dasherize = function(str) {\n  str = str.replace(spaceOrUnderbar, '-');\n  return str;\n};\n\n/*\n  This function adds titleize support to every String object\n    Signature:\n      titleize(str) == String\n    Arguments:\n      str - String - string to apply inflection on\n    Returns:\n      String - capitalizes words as you would for a book title\n    Examples:\n      \"message_properties\".titleize() == \"Message Properties\"\n      \"message properties to keep\".titleize() == \"Message Properties to Keep\"\n*/\nexports.titleize = function(str) {\n  str = str.toLowerCase();\n  str = str.replace(underbar, ' ');\n  var str_arr = str.split(' ');\n  for (var x = 0; x < str_arr.length; x++) {\n    var d = str_arr[x].split('-');\n    for (var i = 0; i < d.length; i++) {\n      if (nonTitlecasedWords.indexOf(d[i].toLowerCase()) < 0) {\n        d[i] = exports.capitalize(d[i]);\n      }\n    }\n    str_arr[x] = d.join('-');\n  }\n  str = str_arr.join(' ');\n  str = str.substring(0, 1).toUpperCase() + str.substring(1);\n  return str;\n};\n\n/*\n  This function adds demodulize support to every String object\n    Signature:\n      demodulize(str) == String\n    Arguments:\n      str - String - string to apply inflection on\n    Returns:\n      String - removes module names leaving only class names (Ruby style)\n    Examples:\n      \"Message::Bus::Properties\".demodulize() == \"Properties\"\n*/\nexports.demodulize = function(str) {\n  var str_arr = str.split('::');\n  str = str_arr[str_arr.length - 1];\n  return str;\n};\n\n/*\n  This function adds tableize support to every String object\n    Signature:\n      tableize(str) == String\n    Arguments:\n      str - String - string to apply inflection on\n    Returns:\n      String - renders camel cased words into their underscored plural form\n    Examples:\n      \"MessageBusProperty\".tableize() == \"message_bus_properties\"\n*/\nexports.tableize = function(str) {\n  str = exports.underscore(str);\n  str = exports.pluralize(str);\n  return str;\n};\n\n/*\n  This function adds classification support to every String object\n    Signature:\n      classify(str) == String\n    Arguments:\n      str - String - string to apply inflection on\n    Returns:\n      String - underscored plural nouns become the camel cased singular form\n    Examples:\n      \"message_bus_properties\".classify() == \"MessageBusProperty\"\n*/\nexports.classify = function(str) {\n  str = exports.camelize(str);\n  str = exports.singularize(str);\n  return str;\n};\n\n/*\n  This function adds foreign key support to every String object\n    Signature:\n      foreignKey(str, dropIdUbar) == String\n    Arguments:\n      str - String - string to apply inflection on\n      dropIdUbar - boolean (optional) - default is to seperate id with an\n        underbar at the end of the class name, you can pass true to skip it\n    Returns:\n      String - camel cased singular class names become underscored with id\n    Examples:\n      \"MessageBusProperty\".foreign_key() == \"message_bus_property_id\"\n      \"MessageBusProperty\".foreign_key(true) == \"message_bus_propertyid\"\n*/\nexports.foreignKey = function(str, dropIdUbar) {\n  str = exports.demodulize(str);\n  str = exports.underscore(str);\n  str = str + ((dropIdUbar) ? ('') : ('_')) + 'id';\n  return str;\n};\n\n/*\n  This function adds ordinalize support to every String object\n    Signature:\n      ordinalize(str) == String\n    Arguments:\n      str - String - string to apply inflection on\n    Returns:\n      String - renders all found numbers their sequence like \"22nd\"\n    Examples:\n      \"the 1 pitch\".ordinalize() == \"the 1st pitch\"\n*/\nexports.ordinalize = function(str) {\n  var str_arr = str.split(' ');\n  for (var x = 0; x < str_arr.length; x++) {\n    var i = parseInt(str_arr[x], 10);\n    if (isNan(i)) {\n      var ltd = str_arr[x].substring(str_arr[x].length - 2);\n      var ld = str_arr[x].substring(str_arr[x].length - 1);\n      var suf = \"th\";\n      if (ltd != \"11\" && ltd != \"12\" && ltd != \"13\") {\n        if (ld === \"1\") {\n          suf = \"st\";\n        } else if (ld === \"2\") {\n          suf = \"nd\";\n        } else if (ld === \"3\") {\n          suf = \"rd\";\n        }\n      }\n      str_arr[x] += suf;\n    }\n  }\n  str = str_arr.join(' ');\n  return str;\n};\n\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/config.js":"var fs = require('fs');\nvar path = require('path');\nvar parseDatabaseUrl = require('parse-database-url');\nvar dbmUtil = require('./util');\n\nexports.load = function(fileName, currentEnv) {\n  try {\n    fs.statSync(fileName);\n  } catch(e) {\n    throw new Error(\"Could not find database config file '\" + fileName + \"'\");\n  }\n  var config;\n\n  try {\n    config = require(fileName);\n  } catch(e) {\n    // distinguish broken files from missing ones\n    if (e instanceof SyntaxError){\n      throw e;\n    }\n\n    config = require(path.join(process.cwd(), fileName));\n  }\n\n  for (var env in config) {\n    if (typeof(config[env]) == \"string\") {\n      exports[env] = parseDatabaseUrl(config[env]);\n    } else {\n      //Check config entry's for ENV objects\n      //which will tell us to grab configuration from the environment\n      for (var configEntry in config[env]) {\n        if (config[env][configEntry] && config[env][configEntry].ENV != null){\n          config[env][configEntry] =  process.env[config[env][configEntry].ENV];\n        }\n      }\n      exports[env] = config[env];\n    }\n  }\n\n  if(currentEnv) {\n    setCurrent(currentEnv);\n  } else if(config['default']) {\n    setCurrent(config['default']);\n  } else if(config.env) {\n    setCurrent(config.env);\n  } else {\n    setCurrent(['dev', 'development']);\n  }\n\n  delete exports.load;\n  delete exports.loadUrl;\n};\n\nexports.loadUrl = function(databaseUrl, currentEnv) {\n  var config = parseDatabaseUrl(databaseUrl);\n  if (currentEnv) {\n    exports[currentEnv] = config;\n    setCurrent(currentEnv);\n  } else {\n    exports.urlConfig = config;\n    setCurrent('urlConfig');\n  }\n\n  delete exports.load;\n  delete exports.loadUrl;\n}\n\nvar setCurrent = exports.setCurrent = function (env) {\n  env = dbmUtil.isArray(env) ? env : [env];\n\n  env.forEach(function (current) {\n    if (dbmUtil.isString(current) && exports[current]) {\n      exports.getCurrent = function () {\n        return {\n          env: current,\n          settings: exports[current]\n        };\n      };\n    }\n  });\n\n  if (!exports.getCurrent) {\n    throw new Error(\"Environment(s) '\" + env.join(', ') + \"' not found.\");\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/data_type.js":"module.exports = {\n  CHAR: 'char',\n  STRING: 'string',\n  TEXT: 'text',\n  SMALLINT: 'smallint',\n  INTEGER: 'int',\n  BIG_INTEGER: 'bigint',\n  REAL: 'real',\n  DATE: 'date',\n  DATE_TIME: 'datetime',\n  TIME: 'time',\n  BLOB: 'blob',\n  TIMESTAMP: 'timestamp',\n  BINARY: 'binary',\n  BOOLEAN: 'boolean',\n  DECIMAL: 'decimal'\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/class.js":"/* Simple JavaScript Inheritance\n * By John Resig http://ejohn.org/\n * MIT Licensed.\n */\n// Inspired by base2 and Prototype\nvar initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n\n// The base Class implementation (does nothing)\nClass = function(){};\n\n// Create a new Class that inherits from this class\nClass.extend = function(prop) {\n  var _super = this.prototype;\n\n  // Instantiate a base class (but only create the instance,\n  // don't run the init constructor)\n  initializing = true;\n  var prototype = new this();\n  initializing = false;\n\n  // Copy the properties over onto the new prototype\n  for (var name in prop) {\n    // Check if we're overwriting an existing function\n    prototype[name] = typeof prop[name] == \"function\" &&\n      typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n      (function(name, fn){\n        return function() {\n          var tmp = this._super;\n\n          // Add a new ._super() method that is the same method\n          // but on the super-class\n          this._super = _super[name];\n\n          // The method only need to be bound temporarily, so we\n          // remove it when we're done executing\n          var ret = fn.apply(this, arguments);\n          this._super = tmp;\n\n          return ret;\n        };\n      })(name, prop[name]) :\n      prop[name];\n  }\n\n  // The dummy class constructor\n  function Class() {\n    // All construction is actually done in the init method\n    if ( !initializing && this.init )\n      this.init.apply(this, arguments);\n  }\n\n  // Populate our constructed prototype object\n  Class.prototype = prototype;\n\n  // Enforce the constructor to be what we expect\n  Class.prototype.constructor = Class;\n\n  // And make this class extendable\n  Class.extend = arguments.callee;\n\n  return Class;\n};\n\nmodule.exports = Class;\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/driver/base.js":"var util = require('util');\nvar events = require('events');\nvar type = require('../data_type');\nvar log = require('../log');\nvar Class = require('../class');\n\nmodule.exports = Base = Class.extend({\n  init: function() {\n    this.eventEmmiter = new events.EventEmitter();\n    for(var n in events.EventEmitter.prototype) {\n      this[n] = events.EventEmitter.prototype[n];\n    }\n  },\n\n  close: function() {\n    throw new Error('not yet implemented');\n  },\n\n  mapDataType: function(str) {\n    switch(str) {\n      case type.STRING:\n        return 'VARCHAR';\n      case type.TEXT:\n        return 'TEXT';\n      case type.INTEGER:\n        return 'INTEGER';\n      case type.BIG_INTEGER:\n        return 'BIGINT';\n      case type.DATE_TIME:\n        return 'INTEGER';\n      case type.REAL:\n        return 'REAL';\n      case type.BLOB:\n        return 'BLOB';\n      case type.TIMESTAMP:\n        return 'TIMESTAMP';\n      case type.BINARY:\n        return 'BINARY';\n      case type.BOOLEAN:\n        return 'BOOLEAN';\n      case type.DECIMAL:\n        return 'DECIMAL';\n      case type.CHAR:\n        return 'CHAR';\n      case type.DATE:\n        return 'DATE';\n      case type.SMALLINT:\n        return 'SMALLINT';\n      default:\n        var unknownType = str.toUpperCase();\n        log.warn('Using unknown data type', unknownType);\n        return unknownType;\n    }\n  },\n\n  createDatabase: function() {\n\n    throw new Error('not implemented');\n  },\n\n  switchDatabase: function() {\n    throw new Error('not implemented');\n  },\n\n  dropDatabase: function() {\n    throw new Error('not implemented');\n  },\n\n  recurseCallbackArray: function(foreignKeys, callback)\n  {\n    var self = this;\n\n    if (foreignKeys.length > 0)\n      (foreignKeys.pop())(function() { self.recurseCallbackArray(foreignKeys, callback); } );\n    else\n      callback();\n  },\n\n  bindForeignKey: function(tableName, columnName, fkOptions) {\n    var self = this,\n        mapping = {};\n\n    if(typeof(fkOptions.mapping) === 'string')\n      mapping[columnName] = fkOptions.mapping;\n    else\n      mapping = fkOptions.mapping;\n\n    return function (callback) { self.addForeignKey(tableName, fkOptions.table,\n        fkOptions.name, mapping, fkOptions.rules, callback); };\n  },\n\n  createColumnDef: function(name, spec, options) {\n    name = '\"' + name + '\"';\n    var type       = this.mapDataType(spec.type);\n    var len        = spec.length ? util.format('(%s)', spec.length) : '';\n    var constraint = this.createColumnConstraint(spec, options);\n    return [name, type, len, constraint].join(' ');\n  },\n\n  createMigrationsTable: function(callback) {\n    var options = {\n      columns: {\n        'id': { type: type.INTEGER, notNull: true, primaryKey: true, autoIncrement: true },\n        'name': { type: type.STRING, length: 255, notNull: true},\n        'run_on': { type: type.DATE_TIME, notNull: true}\n      },\n      ifNotExists: true\n    };\n    this.createTable(global.migrationTable, options, callback);\n  },\n\n  createTable: function(tableName, options, callback) {\n    log.verbose('creating table:', tableName);\n    var columnSpecs = options;\n    var tableOptions = {};\n\n    if (options.columns !== undefined) {\n      columnSpecs = options.columns;\n      delete options.columns;\n      tableOptions = options;\n    }\n\n    var ifNotExistsSql = \"\";\n    if(tableOptions.ifNotExists) {\n      ifNotExistsSql = \"IF NOT EXISTS\";\n    }\n\n    var primaryKeyColumns = [];\n    var columnDefOptions = {\n      emitPrimaryKey: false\n    };\n\n    for (var columnName in columnSpecs) {\n      var columnSpec = this.normalizeColumnSpec(columnSpecs[columnName]);\n      columnSpecs[columnName] = columnSpec;\n      if (columnSpec.primaryKey) {\n        primaryKeyColumns.push(columnName);\n      }\n    }\n\n    var pkSql = '';\n    if (primaryKeyColumns.length > 1) {\n      pkSql = util.format(', PRIMARY KEY (%s)', this.quoteArr(primaryKeyColumns).join(', '));\n    } else {\n      columnDefOptions.emitPrimaryKey = true;\n    }\n\n    var columnDefs = [];\n    for (var columnName in columnSpecs) {\n      var columnSpec = columnSpecs[columnName];\n      columnDefs.push(this.createColumnDef(columnName, columnSpec, columnDefOptions));\n    }\n\n    var sql = util.format('CREATE TABLE %s \"%s\" (%s%s)', ifNotExistsSql, tableName, columnDefs.join(', '), pkSql);\n    this.runSql(sql, callback);\n  },\n\n  dropTable: function(tableName, options, callback) {\n\n    if (arguments.length < 3) {\n      callback = options;\n      options = {};\n    }\n\n    var ifExistsSql = '';\n    if (options.ifExists) {\n      ifExistsSql = 'IF EXISTS';\n    }\n    var sql = util.format('DROP TABLE %s \"%s\"', ifExistsSql, tableName);\n    this.runSql(sql, callback);\n  },\n\n  renameTable: function(tableName, newTableName, callback) {\n    throw new Error('not yet implemented');\n  },\n\n  addColumn: function(tableName, columnName, columnSpec, callback) {\n    var def = this.createColumnDef(columnName, this.normalizeColumnSpec(columnSpec), {});\n    var sql = util.format('ALTER TABLE \"%s\" ADD COLUMN %s', tableName, def);\n    this.runSql(sql, callback);\n  },\n\n  removeColumn: function(tableName, columnName, callback) {\n    throw new Error('not yet implemented');\n  },\n\n  renameColumn: function(tableName, oldColumnName, newColumnName, callback) {\n    throw new Error('not yet implemented');\n  },\n\n  changeColumn: function(tableName, columnName, columnSpec, callback) {\n    throw new Error('not yet implemented');\n  },\n\n  quoteArr: function(arr) {\n\n      for(var i = 0; i < arr.length; ++i)\n        arr[i] = '\"' + arr[i] + '\"';\n\n      return arr;\n  },\n\n  addIndex: function(tableName, indexName, columns, unique, callback) {\n    if (typeof(unique) === 'function') {\n      callback = unique;\n      unique = false;\n    }\n\n    if (!Array.isArray(columns)) {\n      columns = [columns];\n    }\n    var sql = util.format('CREATE %s INDEX \"%s\" ON \"%s\" (%s)', (unique ? 'UNIQUE' : ''),\n      indexName, tableName, this.quoteArr(columns).join(', '));\n\n    this.runSql(sql, callback);\n  },\n\n  insert: function(tableName, columnNameArray, valueArray, callback) {\n    if (columnNameArray.length !== valueArray.length) {\n      return callback(new Error('The number of columns does not match the number of values.'));\n    }\n\n    var sql = util.format('INSERT INTO \"%s\" ', tableName);\n    var columnNames = '(';\n    var values = 'VALUES (';\n\n    for (var index in columnNameArray) {\n      columnNames += columnNameArray[index];\n\n      if (typeof(valueArray[index]) === 'string') {\n        values += \"'\" + this.escape(valueArray[index]) + \"'\";\n      } else {\n        values += valueArray[index];\n      }\n\n      if (index != columnNameArray.length - 1) {\n       columnNames += \",\";\n       values +=  \",\";\n      }\n    }\n\n    sql += columnNames + ') '+ values + ');';\n    this.runSql(sql, callback);\n  },\n\n  removeIndex: function(tableName, indexName, callback) {\n    if (arguments.length === 2 && typeof(indexName) === 'function') {\n      callback = indexName;\n      indexName = tableName;\n    } else if (arguments.length === 1 && typeof(tableName) === 'string') {\n      indexName = tableName;\n    }\n\n    var sql = util.format('DROP INDEX \"%s\"', indexName);\n    this.runSql(sql, callback);\n  },\n\n  addForeignKey: function() {\n    throw new Error('not implemented');\n  },\n\n  removeForeignKey: function() {\n    throw new Error('not implemented');\n  },\n\n  normalizeColumnSpec: function(obj) {\n    if (typeof(obj) === 'string') {\n      return { type: obj };\n    } else {\n      return obj;\n    }\n  },\n\n  addMigrationRecord: function (name, callback) {\n    this.runSql('INSERT INTO \"' + global.migrationTable + '\" (name, run_on) VALUES (?, ?)', [name, new Date()], callback);\n  },\n\n  startMigration: function(cb){cb();},\n  endMigration: function(cb){cb();},\n  // sql, params, callback\n  // sql, callback\n  runSql: function() {\n    throw new Error('not implemented');\n  },\n\n  /**\n    * Queries the migrations table\n    *\n    * @param callback\n    */\n  allLoadedMigrations: function(callback) {\n    var sql = 'SELECT * FROM \"' + global.migrationTable + '\" ORDER BY run_on DESC, name DESC';\n    return this.all(sql, callback);\n  },\n\n  /**\n    * Deletes a migration\n    *\n    * @param migrationName   - The name of the migration to be deleted\n    */\n  deleteMigration: function(migrationName, callback) {\n    var sql = 'DELETE FROM \"' + global.migrationTable + '\" WHERE name = ?';\n    this.runSql(sql, [migrationName], callback);\n  },\n\n  all: function(sql, params, callback) {\n    throw new Error('not implemented');\n  },\n\n  escape: function(str) {\n    return str.replace(/'/g, \"''\");\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/driver/mongodb.js":"var util = require('util');\nvar moment = require('moment');\nvar MongoClient = require('mongodb').MongoClient;\nvar Server = require('mongodb').Server;\nvar Base = require('./base');\nvar type = require('../data_type');\nvar log = require('../log');\n\nvar connectionString;\n\nvar MongodbDriver = Base.extend({\n\n  init: function(connection, mongoString) {\n    this._super();\n    this.connection = connection;\n    connectionString = mongoString;\n  },\n\n  /**\n   * Creates the migrations collection\n   *\n   * @param callback\n   */\n  _createMigrationsCollection: function(callback) {\n    this._run('createCollection', global.migrationTable, null, callback);\n  },\n\n  /**\n   * An alias for _createMigrationsCollection\n   */\n  createMigrationsTable: function(callback) {\n    this._createMigrationsCollection(callback);\n  },\n\n  /**\n   * Creates a collection\n   *\n   * @param collectionName  - The name of the collection to be created\n   * @param callback\n   */\n  createCollection: function(collectionName, callback) {\n    this._run('createCollection', collectionName, null, callback);\n  },\n\n  switchDatabase: function(options, callback) {\n\n    if(typeof(options) === 'object')\n    {\n      if(typeof(options.database) === 'string')\n        this._run('use', options, null, callback);\n    }\n    else if(typeof(options) === 'string')\n    {\n      this._run('use', options, null, callback);\n    }\n    else\n      callback(null);\n  },\n\n  createDatabase: function(dbName, options, callback) {\n    //Don't care at all, MongoDB auto creates databases\n    if(typeof(options) === 'function')\n      callback = options;\n\n    callback(null);\n  },\n\n  dropDatabase: function(dbName, options, callback) {\n\n    if(typeof(options) === 'function')\n      callback = options;\n\n    this._run('dropDatabase', dbName, null, callback);\n  },\n\n  /**\n   * An alias for createCollection\n   *\n   * @param collectionName  - The name of the collection to be created\n   * @param callback\n   */\n  createTable: function(collectionName, callback) {\n    this.createCollection(collectionName, callback);\n  },\n\n  /**\n   * Drops a collection\n   *\n   * @param collectionName  - The name of the collection to be dropped\n   * @param callback\n   */\n  dropCollection: function(collectionName, callback) {\n    this._run('dropCollection', collectionName, null, callback);\n  },\n\n  /**\n   * An alias for dropCollection\n   *\n   * @param collectionName  - The name of the collection to be dropped\n   * @param callback\n   */\n  dropTable: function(collectionName, callback) {\n    this.dropCollection(collectionName, callback);\n  },\n\n  /**\n   * Renames a collection\n   *\n   * @param collectionName    - The name of the existing collection to be renamed\n   * @param newCollectionName - The new name of the collection\n   * @param callback\n   */\n  renameCollection: function(collectionName, newCollectionName, callback) {\n    this._run('renameCollection', collectionName, {newCollection: newCollectionName}, callback);\n  },\n\n  /**\n   * An alias for renameCollection\n   *\n   * @param collectionName    - The name of the existing collection to be renamed\n   * @param newCollectionName - The new name of the collection\n   * @param callback\n   */\n  renameTable: function(collectionName, newCollectionName, callback) {\n    this.renameCollection(collectionName, newCollectionName, callback);\n  },\n\n  /**\n   * Adds an index to a collection\n   *\n   * @param collectionName  - The collection to add the index to\n   * @param indexName       - The name of the index to add\n   * @param columns         - The columns to add an index on\n   * @param\tunique          - A boolean whether this creates a unique index\n   */\n  addIndex: function(collectionName, indexName, columns, unique, callback) {\n\n    var options = {\n      indexName: indexName,\n      columns: columns,\n      unique: unique\n    };\n\n    this._run('createIndex', collectionName, options, callback);\n  },\n\n  /**\n   * Removes an index from a collection\n   *\n   * @param collectionName  - The collection to remove the index\n   * @param indexName       - The name of the index to remove\n   * @param columns\n   */\n  removeIndex: function(collectionName, indexName, callback) {\n    this._run('dropIndex', collectionName, {indexName: indexName}, callback);\n  },\n\n  /**\n   * Inserts a record(s) into a collection\n   *\n   * @param collectionName  - The collection to insert into\n   * @param toInsert        - The record(s) to insert\n   * @param callback\n   */\n  insert: function(collectionName, toInsert, callback) {\n    this._run('insert', collectionName, toInsert, callback);\n  },\n\n  /**\n   * Inserts a migration record into the migration collection\n   *\n   * @param name                - The name of the migration being run\n   * @param callback\n   */\n  addMigrationRecord: function (name, callback) {\n    this._run('insert', global.migrationTable, {name: name, run_on: new Date}, callback);\n  },\n\n  /**\n   * Runs a query\n   *\n   * @param collectionName  - The collection to query on\n   * @param query           - The query to run\n   * @param callback\n   */\n  _find: function(collectionName, query, callback) {\n    this._run('find', collectionName, query, callback);\n  },\n\n  /**\n   * Gets all the collection names in mongo\n   *\n   * @param callback  - The callback to call with the collection names\n   */\n  _getCollectionNames: function(callback) {\n    this._run('collections', null, null, callback);\n  },\n\n  /**\n   * Gets all the indexes for a specific collection\n   *\n   * @param collectionName  - The name of the collection to get the indexes for\n   * @param callback        - The callback to call with the collection names\n   */\n  _getIndexes: function(collectionName, callback) {\n    this._run('indexInformation', collectionName, null, callback);\n  },\n\n  /**\n   * Gets a connection and runs a mongo command and returns the results\n   *\n   * @param command     - The command to run against mongo\n   * @param collection  - The collection to run the command on\n   * @param options     - An object of options to be used based on the command\n   * @arapm callback    - A callback to return the results\n   */\n  _run: function(command, collection, options, callback) {\n\n    var args = this._makeParamArgs(arguments),\n        sort = null,\n        callback = args[2];\n    log.sql.apply(null, arguments);\n\n    if(options && typeof(options) === 'object') {\n\n      if(options.sort)\n        sort = options.sort;\n    }\n\n    if(global.dryRun) {\n      return callback();\n    }\n\n    // Get a connection to mongo\n    this.connection.connect(connectionString, function(err, db) {\n\n      if(err) {\n        return callback(err);\n      }\n\n      // Callback function to return mongo records\n      var callbackFunction = function(err, data) {\n\n        if(err) {\n          return callback(err);\n        }\n\n        callback(null, data);\n        db.close();\n      };\n\n      // Depending on the command, we need to use different mongo methods\n      switch(command) {\n        case 'find':\n\n          if(sort) {\n            db.collection(collection)[command](options.query).sort(sort).toArray(callbackFunction);\n          }\n          else {\n            db.collection(collection)[command](options).toArray(callbackFunction);\n          }\n          break;\n        case 'renameCollection':\n          db[command](collection, options.newCollection, callbackFunction);\n          break;\n        case 'createIndex':\n          db[command](collection, options.columns, {name: options.indexName, unique: options.unique}, callbackFunction);\n          break;\n        case 'dropIndex':\n          db.collection(collection)[command](options.indexName, callbackFunction);\n          break;\n        case 'insert':\n          // options is the records to insert in this case\n          db.collection(collection)[command](options, {}, callbackFunction);\n          break;\n        case 'remove':\n          // options is the records to insert in this case\n          db.collection(collection)[command]({name:options.toRemove}, callbackFunction);\n          break;\n        case 'collections':\n          db.collections(callbackFunction);\n          break;\n        case 'indexInformation':\n          db.indexInformation(collection, callbackFunction);\n          break;\n        case 'dropDatabase':\n          db.dropDatabase(callbackFunction);\n          break;\n        case 'use':\n          db.db(collection, callbackFunction);\n          break;\n        default:\n          db[command](collection, callbackFunction);\n          break;\n      }\n    });\n  },\n\n  _makeParamArgs: function(args) {\n    var params = Array.prototype.slice.call(args);\n    var sql = params.shift();\n    var callback = params.pop();\n\n    if (params.length > 0 && Array.isArray(params[0])) {\n      params = params[0];\n    }\n\n    return [sql, params, callback];\n  },\n\n  /**\n   * Runs a NoSQL command regardless of the dry-run param\n   */\n  _all: function() {\n    var args = this._makeParamArgs(arguments);\n    return this.connection.query.apply(this.connection, args);\n  },\n\n  /**\n   * Queries the migrations collection\n   *\n   * @param callback\n   */\n  allLoadedMigrations: function(callback) {\n    this._run('find', global.migrationTable, { sort: { run_on: -1 } }, callback);\n  },\n\n  /**\n   * Deletes a migration\n   *\n   * @param migrationName       - The name of the migration to be deleted\n   * @param callback\n   */\n  deleteMigration: function(migrationName, callback) {\n    this._run('remove', global.migrationTable, {toRemove: migrationName}, callback);\n  },\n\n  /**\n   * Closes the connection to mongodb\n   */\n  close: function(callback) {\n    this.connection.close(callback);\n  }\n});\n\n/**\n * Gets a connection to mongo\n *\n * @param config    - The config to connect to mongo\n * @param callback  - The callback to call with a MongodbDriver object\n */\nexports.connect = function(config, callback) {\n  var db;\n  var port;\n  var host;\n\n  // Make sure the database is defined\n  if(config.database === undefined) {\n    throw new Error('database must be defined in database.json');\n  }\n\n  if(config.host === undefined) {\n    host = 'localhost';\n  } else {\n    host = config.host;\n  }\n\n  if(config.port === undefined) {\n    port = 27017;\n  } else {\n    port = config.port;\n  }\n\n  var mongoString = 'mongodb://'; \n  \n  if(config.user !== undefined && config.password !== undefined) {\n    mongoString += config.user + ':' + config.password + '@';\n  }\n\n  mongoString += host + ':' + port + '/' + config.database;\n\n  db = config.db || new MongoClient(new Server(host, port));\n  callback(null, new MongodbDriver(db, mongoString));\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/driver/mysql.js":"var util = require('util');\nvar moment = require('moment');\nvar mysql = require('mysql');\nvar Base = require('./base');\nvar type = require('../data_type');\nvar log = require('../log');\n\nvar MysqlDriver = Base.extend({\n  init: function(connection) {\n    this._super();\n    this.connection = connection;\n  },\n\n  mapDataType: function(spec) {\n    var len;\n    switch(spec.type) {\n      case type.TEXT:\n        len = parseInt(spec.length, 10) || 1000;\n        if(len > 16777216) {\n          return 'LONGTEXT';\n        }\n        if(len > 65536) {\n          return 'MEDIUMTEXT';\n        }\n        if(len > 256) {\n          return 'TEXT';\n        }\n        return 'TINYTEXT';\n      case type.DATE_TIME:\n        return 'DATETIME';\n      case type.BLOB:\n        len = parseInt(spec.length, 10) || 1000;\n        if(len > 16777216) {\n          return 'LONGBLOB';\n        }\n        if(len > 65536) {\n          return 'MEDIUMBLOB';\n        }\n        if(len > 256) {\n          return 'BLOB';\n        }\n        return 'TINYBLOB';\n      case type.BOOLEAN:\n        return 'TINYINT(1)';\n    }\n    return this._super(spec.type);\n  },\n\n  createColumnDef: function(name, spec, options, tableName) {\n    var escapedName = util.format('`%s`', name),\n        t = this.mapDataType(spec),\n        len;\n    if(spec.type !== type.TEXT && spec.type !== type.BLOB) {\n      len = spec.length ? util.format('(%s)', spec.length) : '';\n      if (t === 'VARCHAR' && len === '') {\n        len = '(255)';\n      }\n    }\n    var constraint = this.createColumnConstraint(spec, options, tableName, name);\n    return { foreignKey: constraint.foreignKey,\n             constraints: [escapedName, t, len, constraint.constraints].join(' ') };\n  },\n\n  createColumnConstraint: function(spec, options, tableName, columnName) {\n    var constraint = [];\n    var cb;\n\n    if (spec.unsigned) {\n      constraint.push('UNSIGNED');\n    }\n\n    if (spec.primaryKey) {\n      if (!options || options.emitPrimaryKey) {\n        constraint.push('PRIMARY KEY');\n      }\n    }\n\n    if(spec.primaryKey || spec.unique) {\n      if (spec.autoIncrement) {\n        constraint.push('AUTO_INCREMENT');\n      }\n    }\n\n    if (spec.notNull === true) {\n      constraint.push('NOT NULL');\n    }\n\n    if (spec.unique) {\n      constraint.push('UNIQUE');\n    }\n\n    if (spec.null || spec.notNull === false) {\n      constraint.push('NULL');\n    }\n\n    if (spec.defaultValue !== undefined) {\n      constraint.push('DEFAULT');\n\n      if (typeof spec.defaultValue === 'string'){\n        constraint.push(\"'\" + spec.defaultValue + \"'\");\n      } else if (spec.defaultValue === null) {\n        constraint.push('NULL');\n      } else {\n        constraint.push(spec.defaultValue);\n      }\n    }\n\n    if (spec.foreignKey) {\n\n      cb = this.bindForeignKey(tableName, columnName, spec.foreignKey);\n    }\n\n    return { foreignKey: cb, constraints: constraint.join(' ') };\n  },\n\n  createTable: function(tableName, options, callback) {\n    log.verbose('creating table:', tableName);\n    var columnSpecs = options,\n        tableOptions = {};\n\n    if (options.columns !== undefined) {\n      columnSpecs = options.columns;\n      delete options.columns;\n      tableOptions = options;\n    }\n\n    var ifNotExistsSql = \"\";\n    if(tableOptions.ifNotExists) {\n      ifNotExistsSql = \"IF NOT EXISTS\";\n    }\n\n    var primaryKeyColumns = [];\n    var columnDefOptions = {\n      emitPrimaryKey: false\n    };\n\n    for (var columnName in columnSpecs) {\n      var columnSpec = this.normalizeColumnSpec(columnSpecs[columnName]);\n      columnSpecs[columnName] = columnSpec;\n      if (columnSpec.primaryKey) {\n        primaryKeyColumns.push(columnName);\n      }\n    }\n\n    var pkSql = '';\n    if (primaryKeyColumns.length > 1) {\n      pkSql = util.format(', PRIMARY KEY (`%s`)', primaryKeyColumns.join('`, `'));\n    } else {\n      columnDefOptions.emitPrimaryKey = true;\n    }\n\n    var columnDefs = [];\n    var foreignKeys = [];\n    for (var columnName in columnSpecs) {\n      var columnSpec = columnSpecs[columnName];\n      var constraint = this.createColumnDef(columnName, columnSpec, columnDefOptions, tableName);\n\n      columnDefs.push(constraint.constraints);\n      if (constraint.foreignKey)\n        foreignKeys.push(constraint.foreignKey);\n    }\n\n    var sql = util.format('CREATE TABLE %s `%s` (%s%s)', ifNotExistsSql, tableName, columnDefs.join(', '), pkSql);\n\n    this.runSql(sql, function()\n    {\n\n        this.recurseCallbackArray(foreignKeys, callback);\n    }.bind(this));\n  },\n\n  renameTable: function(tableName, newTableName, callback) {\n    var sql = util.format('RENAME TABLE `%s` TO `%s`', tableName, newTableName);\n    this.runSql(sql, callback);\n  },\n\n  addColumn: function(tableName, columnName, columnSpec, callback) {\n    var def = this.createColumnDef(columnName, this.normalizeColumnSpec(columnSpec), {}, tableName);\n    var sql = util.format('ALTER TABLE `%s` ADD COLUMN %s', tableName, def.constraints);\n    this.runSql(sql, function()\n    {\n      if(def.foreignKey)\n        def.foreignKey(callback);\n      else\n        callback();\n    });\n  },\n\n  createDatabase: function(dbName, options, callback) {\n\n    var spec = '',\n        ifNotExists = '';\n\n    if(typeof(options) === 'function')\n      callback = options;\n    else\n    {\n      ifNotExists = (options.ifNotExists === true) ? 'IF NOT EXISTS' : '';\n    }\n\n    this.runSql(util.format('CREATE DATABASE %s `%s` %s', ifNotExists, dbName, spec), callback);\n  },\n\n  switchDatabase: function(options, callback) {\n\n    if(typeof(options) === 'object')\n    {\n      if(typeof(options.database) === 'string')\n        this.runSql(util.format('USE `%s`', options.database), callback);\n    }\n    else if(typeof(options) === 'string')\n    {\n      this.runSql(util.format('USE `%s`', options), callback);\n    }\n    else\n      callback(null);\n  },\n\n  dropDatabase: function(dbName, options, callback) {\n\n    var ifExists = '';\n\n    if(typeof(options) === 'function')\n      callback = options;\n    else\n    {\n      ifExists = (options.ifExists === true) ? 'IF EXISTS' : '';\n    }\n\n    this.runSql(util.format('DROP DATABASE %s `%s`', ifExists, dbName), callback);\n  },\n\n  removeColumn: function(tableName, columnName, callback) {\n    var sql = util.format('ALTER TABLE `%s` DROP COLUMN `%s`', tableName, columnName);\n    this.runSql(sql, callback);\n  },\n\n  addIndex: function(tableName, indexName, columns, unique, callback) {\n    if (typeof(unique) === 'function') {\n      callback = unique;\n      unique = false;\n    }\n\n    if (!Array.isArray(columns)) {\n      columns = [columns];\n    }\n    var sql = util.format('ALTER TABLE `%s` ADD %s INDEX `%s` (`%s`)', tableName, (unique ? 'UNIQUE ' : ''), indexName, columns.join('`, `'));\n    this.runSql(sql, callback);\n  },\n\n  insert: function(tableName, columnNameArray, valueArray, callback) {\n    if (columnNameArray.length !== valueArray.length) {\n      return callback(new Error('The number of columns does not match the number of values.'));\n    }\n\n    var sql = util.format('INSERT INTO `%s` ', tableName);\n    var columnNames = '(';\n    var values = 'VALUES (';\n\n    for (var index in columnNameArray) {\n      columnNames += '`' + columnNameArray[index] + '`';\n\n      if (typeof(valueArray[index]) === 'string') {\n        values += \"'\" + this.escape(valueArray[index]) + \"'\";\n      } else {\n        values += valueArray[index];\n      }\n\n      if (index != columnNameArray.length - 1) {\n        columnNames += \",\";\n        values +=  \",\";\n      }\n    }\n\n    sql += columnNames + ') '+ values + ');';\n    this.runSql(sql, callback);\n  },\n\n  removeIndex: function(tableName, indexName, callback) {\n    // tableName is optional for other drivers, but required for mySql. So, check the args to ensure they are valid\n    if (arguments.length === 2 && typeof(indexName) === 'function') {\n      callback = indexName;\n      process.nextTick(function () {\n        callback(new Error('Illegal arguments, must provide \"tableName\" and \"indexName\"'));\n      });\n\n      return;\n    }\n\n    var sql = util.format('DROP INDEX `%s` ON `%s`', indexName, tableName);\n    this.runSql(sql, callback);\n  },\n\n  dropTable: function(tableName, options, callback) {\n    if (arguments.length < 3) {\n      callback = options;\n      options = {};\n    }\n\n    var ifExistsSql = '';\n    if (options.ifExists) {\n      ifExistsSql = 'IF EXISTS';\n    }\n    var sql = util.format('DROP TABLE %s `%s`', ifExistsSql, tableName);\n    this.runSql(sql, callback);\n  },\n\n  renameColumn: function(tableName, oldColumnName, newColumnName, callback) {\n    var self = this, columnTypeSql = util.format(\"SELECT COLUMN_TYPE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '%s' AND COLUMN_NAME = '%s'\", tableName, oldColumnName);\n\n    this.all(columnTypeSql, function(err, result) {\n      var columnType = result[0].COLUMN_TYPE;\n      var alterSql = util.format(\"ALTER TABLE `%s` CHANGE `%s` `%s` %s\", tableName, oldColumnName, newColumnName, columnType);\n      self.runSql(alterSql, callback);\n    });\n  },\n\n  changeColumn: function(tableName, columnName, columnSpec, callback) {\n    var constraint = this.createColumnDef(columnName, columnSpec);\n    var sql = util.format('ALTER TABLE `%s` CHANGE COLUMN `%s` %s', tableName, columnName, constraint.constraints);\n\n    var exec = function() {\n\n      this.runSql(sql, function()\n      {\n        if(constraint.foreignKey)\n          constraint.foreignKey(callback);\n        else\n          callback();\n      });\n    }.bind(this);\n\n    if(columnSpec.unique === false)\n      this.removeIndex(tableName, columnName, exec);\n    else\n      exec();\n  },\n\n  addMigrationRecord: function (name, callback) {\n    var formattedDate = moment(new Date()).format('YYYY-MM-DD HH:mm:ss');\n    this.runSql('INSERT INTO `' + global.migrationTable + '` (`name`, `run_on`) VALUES (?, ?)', [name, formattedDate], callback);\n  },\n\n  addForeignKey: function(tableName, referencedTableName, keyName, fieldMapping, rules, callback) {\n    if(arguments.length === 5 && typeof(rules) === 'function') {\n      callback = rules;\n      rules = {};\n    }\n    var columns = Object.keys(fieldMapping);\n    var referencedColumns = columns.map(function (key) { return fieldMapping[key]; });\n    var sql = util.format('ALTER TABLE `%s` ADD CONSTRAINT `%s` FOREIGN KEY (%s) REFERENCES `%s` (%s) ON DELETE %s ON UPDATE %s',\n      tableName, keyName, this.tableQuoteArr( columns ), referencedTableName,\n      this.tableQuoteArr( referencedColumns ), rules.onDelete || 'NO ACTION', rules.onUpdate || 'NO ACTION');\n    this.runSql(sql, callback);\n  },\n\n  removeForeignKey: function(tableName, keyName, options, callback) {\n    var sql = util.format('ALTER TABLE `%s` DROP FOREIGN KEY `%s`', tableName, keyName);\n    this.runSql(sql, function () {\n\n      if( typeof(options) === 'function' ) {\n\n          options();\n      }\n      else if(options.dropIndex === true) {\n\n        sql = util.format('ALTER TABLE `%s` DROP INDEX `%s`', tableName, keyName);\n        this.runSql(sql, function () {\n          callback();\n        });\n      }\n      else\n        callback();\n\n    }.bind(this));\n  },\n\n  tableQuoteArr: function(arr) {\n\n      for(var i = 0; i < arr.length; ++i)\n        arr[i] = '`' + arr[i] + '`';\n\n      return arr;\n  },\n\n  runSql: function() {\n\n    var args = this._makeParamArgs(arguments);\n    var callback = args[2];\n    log.sql.apply(null, arguments);\n    if(global.dryRun) {\n      return callback();\n    }\n\n    return this.connection.query.apply(this.connection, args);\n  },\n\n  _makeParamArgs: function(args) {\n    var params = Array.prototype.slice.call(args);\n    var sql = params.shift();\n    var callback = params.pop();\n\n    if (params.length > 0 && Array.isArray(params[0])) {\n      params = params[0];\n    }\n    return [sql, params, callback];\n  },\n\n  all: function() {\n    var args = this._makeParamArgs(arguments);\n\n    log.sql.apply(null, arguments);\n\n    return this.connection.query.apply(this.connection, args);\n  },\n\n  /**\n   * Queries the migrations table\n   *\n   * @param callback\n   */\n  allLoadedMigrations: function(callback) {\n    var sql = 'SELECT * FROM `' + global.migrationTable + '` ORDER BY run_on DESC, name DESC';\n    this.all(sql, callback);\n  },\n\n  /**\n   * Deletes a migration\n   *\n   * @param migrationName\t\t- The name of the migration to be deleted\n   * @param callback\n   */\n  deleteMigration: function(migrationName, callback) {\n    var sql = 'DELETE FROM `' + global.migrationTable + '` WHERE name = ?';\n    this.runSql(sql, [migrationName], callback);\n  },\n\n  close: function(callback) {\n    this.connection.end(callback);\n  }\n\n});\n\nexports.connect = function(config, callback) {\n  var db;\n  if (typeof(mysql.createConnection) === 'undefined') {\n    db = config.db || new mysql.createClient(config);\n  } else {\n    db = config.db || new mysql.createConnection(config);\n  }\n\n  db.connect(function( err ) {\n\n    if( err ) {\n      return callback( err );\n    }\n\n    callback(null, new MysqlDriver(db));\n  } )\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/driver/pg.js":"var util = require('util');\nvar pg = require('pg');\nvar semver = require('semver');\nvar Base = require('./base');\nvar type = require('../data_type');\nvar log = require('../log');\n\nvar PgDriver = Base.extend({\n    init: function(connection, schema) {\n        this._super();\n        this.connection = connection;\n        this.schema = schema || \"public\";\n        this.connection.connect();\n    },\n\n    startMigration: function(cb){\n        this.runSql('BEGIN;', function() { cb();});\n    },\n\n    endMigration: function(cb){\n        this.runSql('COMMIT;', function(){cb(null);});\n    },\n\n    createColumnDef: function(name, spec, options) {\n        var type = spec.autoIncrement ? '' : this.mapDataType(spec.type);\n        var len = spec.length ? util.format('(%s)', spec.length) : '';\n        var constraint = this.createColumnConstraint(spec, options);\n        if (name.charAt(0) != '\"') {\n            name = '\"' + name + '\"';\n        }\n        return [name, type, len, constraint].join(' ');\n    },\n\n    mapDataType: function(str) {\n        switch(str) {\n          case type.STRING:\n            return 'VARCHAR';\n          case type.DATE_TIME:\n            return 'TIMESTAMP';\n          case type.BLOB:\n            return 'BYTEA';\n        }\n        return this._super(str);\n    },\n\n    createDatabase: function(dbName, options, callback) {\n\n      var spec = '';\n\n      if(typeof(options) === 'function')\n        callback = options;\n\n      this.runSql(util.format('CREATE DATABASE \"%s\" %s', dbName, spec), callback);\n    },\n\n    dropDatabase: function(dbName, options, callback) {\n\n      var ifExists = '';\n\n      if(typeof(options) === 'function')\n        callback = options;\n      else\n      {\n        ifExists = (options.ifExists === true) ? 'IF EXISTS' : '';\n      }\n\n      this.runSql(util.format('DROP DATABASE %s \"%s\"', ifExists, dbName), callback);\n    },\n\n    createSequence: function(sqName, options, callback) {\n\n      var spec = '',\n          temp = '';\n\n      if(typeof(options) === 'function')\n        callback = options;\n      else\n      {\n        temp = (options.temp === true) ? 'TEMP' : '';\n      }\n\n      this.runSql(util.format('CREATE %s SEQUENCE `%s` %s', temp, sqName, spec), callback);\n    },\n\n    switchDatabase: function(options, callback) {\n\n      if(typeof(options) === 'object')\n      {\n        if(typeof(options.database) === 'string')\n        {\n          log.info('Ignore database option, not available with postgres. Use schema instead!');\n          this.runSql(util.format('SET search_path TO `%s`', options.database), callback);\n        }\n      }\n      else if(typeof(options) === 'string')\n      {\n        this.runSql(util.format('SET search_path TO `%s`', options), callback);\n      }\n      else\n        callback(null);\n    },\n\n    dropSequence: function(dbName, options, callback) {\n\n      var ifExists = '',\n          rule = '';\n\n      if(typeof(options) === 'function')\n        callback = options;\n      else\n      {\n        ifExists = (options.ifExists === true) ? 'IF EXISTS' : '';\n\n        if(options.cascade === true)\n          rule = 'CASCADE';\n        else if(options.restrict === true)\n          rule = 'RESTRICT';\n      }\n\n      this.runSql(util.format('DROP SEQUENCE %s `%s` %s', ifExists, dbName, rule), callback);\n    },\n\n    createMigrationsTable: function(callback) {\n      var options = {\n        columns: {\n          'id': { type: type.INTEGER, notNull: true, primaryKey: true, autoIncrement: true },\n          'name': { type: type.STRING, length: 255, notNull: true},\n          'run_on': { type: type.DATE_TIME, notNull: true}\n        },\n        ifNotExists: false\n      };\n\n      this.all('select version() as version', function(err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (result && result && result.length > 0 && result[0].version) {\n          var version = result[0].version;\n          var match = version.match(/\\d+\\.\\d+\\.\\d+/);\n          if (match && match[0] && semver.gte(match[0], '9.1.0')) {\n            options.ifNotExists = true;\n          }\n        }\n\n        // Get the current search path so we can change the current schema\n        // if necessary\n        this.all(\"SHOW search_path\", function(err, result) {\n            if (err) {\n                return callback(err);\n            }\n\n            var searchPath,\n                search_pathes = result[0].search_path.split(',');\n\n            for (var i = 0; i < search_pathes.length; ++i) {\n              if (search_pathes[i].indexOf('\"') !== 0) {\n                search_pathes[i] = '\"' + search_pathes[i].trim() + '\"';\n              }\n            }\n\n            result[0].search_path = search_pathes.join(',');\n\n            // if the user specified a different schema, prepend it to the\n            // search path. This will make all DDL/DML/SQL operate on the specified\n            // schema.\n            if (this.schema === 'public') {\n                searchPath = result[0].search_path;\n            } else {\n                searchPath = '\"' + this.schema + '\",' + result[0].search_path;\n            }\n\n            this.all('SET search_path TO ' + searchPath, function() {\n                this.all(\"SELECT table_name FROM information_schema.tables WHERE table_name = '\" +\n                  global.migrationTable + \"'\" +\n                  (this.schema ?\n                    \" AND table_schema = '\" + this.schema + \"'\" :\n                    ''),\n                  function(err, result) {\n                    if (err) {\n                      return callback(err);\n                    }\n\n                    if (result && result && result.length < 1) {\n                      this.createTable(global.migrationTable, options, callback);\n                    } else {\n                      callback();\n                    }\n                  }.bind(this));\n            }.bind(this));\n        }.bind(this));\n      }.bind(this));\n    },\n\n    createColumnConstraint: function(spec, options) {\n        var constraint = [];\n        if (spec.primaryKey && options.emitPrimaryKey) {\n            if (spec.autoIncrement) {\n                constraint.push('SERIAL');\n            }\n            constraint.push('PRIMARY KEY');\n        }\n\n        if (spec.notNull === true) {\n            constraint.push('NOT NULL');\n        }\n\n        if (spec.unique) {\n            constraint.push('UNIQUE');\n        }\n\n        if (typeof spec.defaultValue != 'undefined') {\n            constraint.push('DEFAULT');\n            if (typeof spec.defaultValue == 'string'){\n                constraint.push(\"'\" + spec.defaultValue + \"'\");\n            } else {\n              constraint.push(spec.defaultValue);\n            }\n        }\n\n        return constraint.join(' ');\n    },\n\n    renameTable: function(tableName, newTableName, callback) {\n        var sql = util.format('ALTER TABLE \"%s\" RENAME TO \"%s\"', tableName, newTableName);\n        this.runSql(sql, callback);\n    },\n\n    removeColumn: function(tableName, columnName, callback) {\n        var sql = util.format('ALTER TABLE \"%s\" DROP COLUMN \"%s\"', tableName, columnName);\n        this.runSql(sql, callback);\n    },\n\n    renameColumn: function(tableName, oldColumnName, newColumnName, callback) {\n        var sql = util.format('ALTER TABLE \"%s\" RENAME COLUMN \"%s\" TO \"%s\"', tableName, oldColumnName, newColumnName);\n        this.runSql(sql, callback);\n    },\n\n    changeColumn: function(tableName, columnName, columnSpec, callback) {\n      setNotNull.call(this);\n\n      function setNotNull() {\n        var setOrDrop = columnSpec.notNull === true ? 'SET' : 'DROP';\n        var sql = util.format('ALTER TABLE \"%s\" ALTER COLUMN \"%s\" %s NOT NULL', tableName, columnName, setOrDrop);\n        this.runSql(sql, setUnique.bind(this));\n      }\n\n      function setUnique(err) {\n        if (err) {\n          callback(err);\n        }\n\n        var sql;\n        var constraintName = tableName + '_' + columnName + '_key';\n\n        if (columnSpec.unique === true) {\n          sql = util.format('ALTER TABLE \"%s\" ADD CONSTRAINT \"%s\" UNIQUE (\"%s\")', tableName, constraintName, columnName);\n          this.runSql(sql, setDefaultValue.bind(this));\n        } else if (columnSpec.unique === false) {\n          sql = util.format('ALTER TABLE \"%s\" DROP CONSTRAINT \"%s\"', tableName, constraintName);\n          this.runSql(sql, setDefaultValue.bind(this));\n        } else {\n          setDefaultValue.call(this);\n        }\n      }\n\n      function setDefaultValue(err) {\n        if (err) {\n          return callback(err);\n        }\n\n        var sql;\n\n        if (columnSpec.defaultValue !== undefined) {\n          var defaultValue = null;\n          if (typeof columnSpec.defaultValue == 'string'){\n            defaultValue = \"'\" + columnSpec.defaultValue + \"'\";\n          } else {\n            defaultValue = columnSpec.defaultValue;\n          }\n          sql = util.format('ALTER TABLE \"%s\" ALTER COLUMN \"%s\" SET DEFAULT %s', tableName, columnName, defaultValue);\n        } else {\n          sql = util.format('ALTER TABLE \"%s\" ALTER COLUMN \"%s\" DROP DEFAULT', tableName, columnName);\n        }\n\n        this.runSql(sql, callback);\n      }\n    },\n\n    addForeignKey: function(tableName, referencedTableName, keyName, fieldMapping, rules, callback) {\n      if(arguments.length === 5 && typeof(rules) === 'function') {\n        callback = rules;\n        rules = {};\n      }\n      var columns = Object.keys(fieldMapping);\n      var referencedColumns = columns.map(function (key) { return '\"' + fieldMapping[key] + '\"'; });\n      var sql = util.format('ALTER TABLE \"%s\" ADD CONSTRAINT \"%s\" FOREIGN KEY (%s) REFERENCES \"%s\" (%s) ON DELETE %s ON UPDATE %s',\n        tableName, keyName, this.quoteArr(columns), referencedTableName, referencedColumns, rules.onDelete || 'NO ACTION', rules.onUpdate || 'NO ACTION');\n      this.runSql(sql, callback);\n    },\n\n    removeForeignKey: function(tableName, keyName, callback) {\n      var sql = util.format('ALTER TABLE \"%s\" DROP CONSTRAINT \"%s\"', tableName, keyName);\n      this.runSql(sql, callback);\n    },\n\n    insert: function(tableName, columnNameArray, valueArray, callback) {\n      columnNameArray = columnNameArray.map(function(columnName) {\n        return (columnName.charAt(0) != '\"') ? '\"' + columnName + '\"' : columnName;\n      });\n\n      valueArray = valueArray.map(function(value) {\n        return 'string' === typeof value ? value : JSON.stringify(value);\n      });\n\n      return this._super(tableName, columnNameArray, valueArray, callback);\n    },\n\n    runSql: function() {\n        var callback = arguments[arguments.length - 1];\n\n        params = arguments;\n        if (params.length > 2){\n            // We have parameters, but db-migrate uses \"?\" for param substitutions.\n            // PG uses \"$1\", \"$2\", etc so fix up the \"?\" into \"$1\", etc\n            var param = params[0].split('?'),\n                new_param = [];\n            for (var i = 0; i < param.length-1; i++){\n                new_param.push(param[i], \"$\" + (i+1));\n            }\n            new_param.push(param[param.length-1]);\n            params[0] = new_param.join('');\n        }\n\n        log.sql.apply(null, params);\n        if(global.dryRun) {\n          return callback();\n        }\n        this.connection.query.apply(this.connection, params);\n    },\n\n    all: function() {\n        params = arguments;\n\n        log.sql.apply(null, params);\n\n        this.connection.query.apply(this.connection, [params[0], function(err, result){\n          if(err) {\n            params[1](err, null);\n            return;\n          }\n\n          params[1](err, result.rows);\n        }]);\n    },\n\n    close: function(callback) {\n        this.connection.end();\n        if( typeof(callback) === 'function' )\n          callback(null);\n    }\n\n});\n\nexports.connect = function(config, callback) {\n    if (config.native) { pg = pg.native; }\n    var db = config.db || new pg.Client(config);\n    callback(null, new PgDriver(db, config.schema));\n};\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/driver/postgres.js":"module.exports = require('./pg');\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/driver/postgresql.js":"module.exports = require('./pg');\n","/home/travis/build/npmtest/node-npmtest-db-migrate/node_modules/db-migrate/lib/driver/sqlite3.js":"var util = require('util');\nvar sqlite3 = require('sqlite3').verbose();\nvar Base = require('./base');\nvar log = require('../log');\nvar type = require('../data_type');\n\nvar defaultMode = sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE;\n\nvar Sqlite3Driver = Base.extend({\n  init: function(connection) {\n    this._super();\n    this.connection = connection;\n  },\n\n  mapDataType: function(str) {\n    switch(str) {\n      case type.DATE_TIME:\n        return 'datetime';\n      case type.TIME:\n        return 'time';\n    }\n    return this._super(str);\n  },\n\n  switchDatabase: function(options, callback) {\n    callback(null);\n  },\n\n  createColumnDef: function(name, spec, options) {\n    name = '\"' + name + '\"';\n    var dType       = this.mapDataType(spec.type);\n    var len        = spec.length ? util.format('(%s)', spec.length) : '';\n    var constraint = this.createColumnConstraint(spec, options);\n\n    if(spec.type === type.INTEGER)\n      len = '';\n\n    return [name, dType, len, constraint].join(' ');\n  },\n\n  createColumnConstraint: function(spec, options) {\n    var constraint = [];\n    if (spec.primaryKey && options.emitPrimaryKey) {\n      constraint.push('PRIMARY KEY');\n      if (spec.autoIncrement) {\n        constraint.push('AUTOINCREMENT');\n      }\n    }\n\n    if (spec.notNull === true) {\n      constraint.push('NOT NULL');\n    }\n\n    if (spec.unique) {\n      constraint.push('UNIQUE');\n    }\n\n    if (spec.defaultValue) {\n      constraint.push('DEFAULT');\n\n      if(typeof(spec.defaultValue) === 'string')\n        constraint.push('\"' + spec.defaultValue + '\"');\n      else\n        constraint.push(spec.defaultValue);\n    }\n\n    return constraint.join(' ');\n  },\n\n  renameTable: function(tableName, newTableName, callback) {\n    var sql = util.format('ALTER TABLE %s RENAME TO %s', tableName, newTableName);\n    this.runSql(sql, callback);\n  },\n\n  //removeColumn: function(tableName, columnName, callback) {\n  //},\n\n  //renameColumn: function(tableName, oldColumnName, newColumnName, callback) {\n  //};\n\n  //changeColumn: function(tableName, columnName, columnSpec, callback) {\n  //},\n\n  runSql: function() {\n    var callback = arguments[arguments.length - 1];\n    log.sql.apply(null, arguments);\n    if(global.dryRun) {\n      return callback();\n    }\n\n    if(typeof(arguments[1]) === 'function')\n      this.connection.exec.apply(this.connection, arguments);\n    else\n      this.connection.run.apply(this.connection, arguments);\n  },\n\n  all: function() {\n\n    log.sql.apply(null, arguments);\n\n    this.connection.all.apply(this.connection, arguments);\n  },\n\n  close: function(callback) {\n    this.connection.close();\n    callback(null);\n  }\n\n});\n\nexports.connect = function(config, callback) {\n  var mode = config.mode || defaultMode;\n  if (config.db) {\n    callback(null, new Sqlite3Driver(config.db));\n  } else {\n    if (typeof(config.filename) === 'undefined') {\n      console.error('filename is required in database.json');\n      return;\n    }\n    var db = new sqlite3.Database(config.filename, mode);\n    db.on(\"error\", callback);\n    db.on(\"open\", function() {\n      callback(null, new Sqlite3Driver(db));\n    });\n  }\n};\n"}